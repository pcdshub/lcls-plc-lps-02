<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_LaserShutterEnable" Id="{52004838-2014-4839-ae20-5315a47326e2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_LaserShutterEnable
VAR_INPUT
    //bAmphosOn : BOOL; // Whether the amphos is on
    fOpcpaVoltage       : LREAL; // The voltage of the OPCPA
    fAmphosVoltage      : LREAL; // The Amphos voltage
    fMPCVoltage         : LREAL; // The MPC voltage
    AmphosStatus        :BOOL; //Amphos Laser Shutter Status
    bLoopTempOverride01 : BOOL; // Whether the chiller loop error is overriden
    bLoopTempOverride02 : BOOL; // Whether the chiller loop error is overriden
    bLoopTempOverride03 : BOOL; // Whether the chiller loop error is overriden
    bLoopTempOverride04 : BOOL; // Whether the chiller loop error is overriden
    bLoopTempOverride05 : BOOL; // Whether the chiller loop error is overriden
    Mode                : E_Mode; // Mode of operation
//    bAmphosShutterIN    : BOOL; // Amphos Shutter Status
//    bShutterStatus      : BOOL; // Shutter Status
END_VAR

VAR_IN_OUT CONSTANT
    stErrors            : ST_ErrorStates; // Currently detected errors
    stOpcpaSetpoints    : ST_LaserSetpoints; // OPCPA setpoints
    stAmphosSetpoints   : ST_LaserSetpoints; // The Amphos setpoints
    stMPCSetpoints      : ST_LaserSetpoints; // The MPC setpoints
END_VAR

VAR
    bChillerErrors      : BOOL; // Local logical sum of chiller error states
    bTempSwitchErrors   : BOOL; // Local logical sum of temperature switch errors
    bAmphosUnderVolt    : BOOL; // Local var for checking Amphos under MinVoltage
    bOpcpaUnderVolt     : BOOL; // Local var for checking OPCPA under MinVoltage
    bMpcUnderVolt       : BOOL; // Local var for checking MPC under MinVoltage
END_VAR

VAR_OUTPUT
    bAmphosShutter   : BOOL; // Allowed Amphos Shutter state, point to NC Relay GVL
    bCarbideShutter  : BOOL; // Allowed Carbide Shutter state, point to NC Relay GVL
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
The Amphos Shutter Enable function sends and Enable or Disable bit as an output to be used by the Amphos Shutter Command block
AmphosShutterEnable := TRUE := OPEN SHUTTER
AmphosShutterEnable := FALSE := CLOSE SHUTTER
The below logic follows the logic table
Note : In master override modes, the Shutter state will hold the previous state value, unless manually forced
*)

bChillerErrors := (
                 (NOT bLoopTempOverride01 AND stErrors.bChillerLoop01) OR
                 (NOT bLoopTempOverride02 AND stErrors.bChillerLoop02) OR
                 (NOT bLoopTempOverride03 AND stErrors.bChillerLoop03) OR
                 (NOT bLoopTempOverride04 AND stErrors.bChillerLoop04) OR
                 (NOT bLoopTempOverride05 AND stErrors.bChillerLoop05)
                 );
bTempSwitchErrors := (
                     NOT GVL_IO.bLoopTempSW01 OR
                     NOT GVL_IO.bLoopTempSW02 OR
                     NOT GVL_IO.bLoopTempSW03 OR
                     NOT GVL_IO.bLoopTempSW04 OR
                     NOT GVL_IO.bLoopTempSW05
                     );

bAmphosUnderVolt := fAmphosVoltage < stAmphosSetpoints.nMinVoltage;
bOpcpaUnderVolt := fOpcpaVoltage < stOpcpaSetpoints.nMinVoltage;
bMpcUnderVolt := fMPCVoltage < stMPCSetpoints.nMinVoltage;

IF (stErrors.bHardwareFailure // Close shutter if there is a hardware failure
    (*OR stErrors.bLeakOpticalTableAmphosOn OR stErrors.bLeakOpcpaCarbideOn OR stErrors.bLeakUnderTable*) // Close shutter if there is a leak on the optical table with the amphos on, a leak under the table, or a leak inside the OPCPA with Carbide on
    //Close shutter if the amphos is on and the temperature is too high in any loop. Ignore if operator override is enabled
     OR (bChillerErrors OR bTempSwitchErrors)
    // Close shutter if in OPCPA beam error state and OPCPA voltage too low
     OR (bOpcpaUnderVolt AND stErrors.bOpcpaBeam)
    // Close the shutter if there is a Dump Chiller error
     OR stErrors.bDumpChiller
    )
    // Check global IO for redundancy of Dump Chiller Errors
    OR (NOT GVL_IO.bDumpChillerFlow)
    OR (NOT GVL_IO.bBaseplateChillerFlow)
THEN
    bAmphosShutter := bCarbideShutter := bCarbideShutter := FALSE;
ELSE
    CASE MODE OF
        // With great overrides comes great responsibility, and burnt optics
        E_Mode.MASTER_Override:
// Just pass and retain the previous Amphos Shutter State
//            bAmphosShutterIN := bAmphosShutterOUT;
            bCarbideShutter := TRUE;

        E_Mode.Protection:
            // If the Amphos trips, always disable it
            IF bAmphosUnderVolt
            THEN
                bAmphosShutter := FALSE;
            ELSE
                bAmphosShutter := TRUE;
            END_IF
            // Only open the Amphos shutter if all 3 lasers are happy
            IF (NOT bAmphosUnderVolt AND NOT bOpcpaUnderVolt AND NOT bMpcUnderVolt)
            THEN
                bAmphosShutter := TRUE;
            ELSE
                bAmphosShutter := FALSE;
            END_IF
            // Carbide Shutter is weird, allows solo Carbide use explicitly
            IF (NOT bAmphosUnderVolt AND NOT bOpcpaUnderVolt AND NOT bMpcUnderVolt)
                OR (bAmphosUnderVolt AND bOpcpaUnderVolt AND NOT bMpcUnderVolt)
            THEN
                bCarbideShutter := TRUE;
            ELSE
                bCarbideShutter := FALSE;
            END_IF

        E_Mode.Maintenance:
        // Just pass the Amphos shutter state and don' do anything
        // Close the carbide shutter if the MPC is unhappy
        IF bMpcUnderVolt
        THEN
            bCarbideShutter := FALSE;
        ELSE
            bCarbideShutter := TRUE;
        END_IF

        // Undefined state, do not get here. Do not pass go, do not collect 200 dollars
        ELSE
        // If you get stuck here you deserve it
    END_CASE
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>